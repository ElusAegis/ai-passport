use crate::config::VerifyConfig;
use anyhow::{Context, Result};
use k256::pkcs8::DecodePublicKey;
use std::time::Duration;
use tlsn_core::presentation::{Presentation, PresentationOutput};
use tlsn_core::signing::VerifyingKey;
use tlsn_core::CryptoProvider;

/// A simple verifier which reads a proof generated by `simple_prover.rs` from "proof.json", verifies
/// it and prints the verified data to the console.
pub(crate) fn run_verify(app_conf: &VerifyConfig) -> Result<()> {
    println!("ðŸš¨ WARNING: Verifying a proof generated by a dummy notary.");
    println!("ðŸš¨ WARNING: Dummy notary is used for testing purposes only. It is not secure and should not be used in production.");

    // Deserialize the attestation presentation
    let ser_attestation =
        std::fs::read_to_string(app_conf.proof_path.as_path()).context(format!(
            "Failed to read proof at {}",
            app_conf.proof_path.to_str().unwrap_or("???"),
        ))?;
    let presentation: Presentation = serde_json::from_str(ser_attestation.as_str())
        .context("Failed to deserialize proof generated by a valid proof")?;

    let VerifyingKey { data: key_data, .. } = presentation.verifying_key();
    let parsed_key = k256::PublicKey::from_sec1_bytes(key_data)
        .context("Failed to parse key from generated by a valid proof")?;

    // Load the Notary's public key
    let notary_key = notary_pubkey()?;

    // Check that the key used to sign the attestation is from a Notary we trust.
    if parsed_key != notary_key {
        return Err(anyhow::anyhow!(
            "The public key used to sign the attestation does not match the trusted Notary's public key."
        ));
    }

    let provider = CryptoProvider::default();

    // Verify the presentation.
    let PresentationOutput {
        server_name,
        connection_info,
        transcript,
        ..
    } = presentation.verify(&provider).unwrap();

    // The time at which the connection was started.
    let time = chrono::DateTime::UNIX_EPOCH + Duration::from_secs(connection_info.time);
    let server_name = server_name.unwrap();
    let mut partial_transcript = transcript.unwrap();
    // Set the unauthenticated bytes so they are distinguishable.
    partial_transcript.set_unauthed(b'X');

    let sent = String::from_utf8_lossy(partial_transcript.sent_unsafe());
    let recv = String::from_utf8_lossy(partial_transcript.received_unsafe());

    println!("-------------------------------------------------------------------");
    println!(
        "Successfully verified that the bytes below came from a session with {:?} at {}.",
        server_name, time
    );
    println!("Note that the bytes which the Prover chose not to disclose are shown as X.");
    println!();
    println!("Messages sent:");
    println!();
    println!("{sent}");
    println!();
    println!("Messages received:");
    println!();
    println!("{recv}");
    println!("-------------------------------------------------------------------");

    Ok(())
}

/// Returns a Notary pubkey trusted by this Verifier
fn notary_pubkey() -> Result<k256::PublicKey> {
    let pem_file = include_str!("../tlsn/notary.pub");

    k256::PublicKey::from_public_key_pem(pem_file).context("Failed to parse notary public key")
}
