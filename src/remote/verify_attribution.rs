use k256::pkcs8::DecodePublicKey;
use std::{str, time::Duration};
use tlsn_core::presentation::{Presentation, PresentationOutput};
use tlsn_core::signing::VerifyingKey;
use tlsn_core::CryptoProvider;

/// A simple verifier which reads a proof generated by `simple_prover.rs` from "proof.json", verifies
/// it and prints the verified data to the console.
pub fn verify_attribution(proof_path: &str) -> Result<(), Box<dyn std::error::Error>> {
    #[cfg(not(feature = "dummy-notary"))]
    Err("Currently unsupported without the dummy-notary feature. Enable the dummy-notary feature to run this example."
        .to_string())?;

    println!("ðŸš¨ WARNING: Verifying a proof generated by a dummy notary.");
    println!("ðŸš¨ WARNING: Dummy notary is used for testing purposes only. It is not secure and should not be used in production.");

    // Deserialize the attestation presentation
    let ser_attestation = std::fs::read_to_string(proof_path)
        .map_err(|e| format!("Failed to read proof at {}: {}", proof_path, e))?;
    let presentation: Presentation = serde_json::from_str(ser_attestation.as_str())
        .map_err(|e| format!("Failed to parse proof: {}", e))?;

    let VerifyingKey { data: key_data, .. } = presentation.verifying_key();
    let parsed_key = k256::PublicKey::from_sec1_bytes(key_data)
        .map_err(|e| format!("Failed to parse public key: {}", e))?;

    // Load the Notary's public key
    let notary_key = notary_pubkey()?;

    // Check that the key used to sign the attestation is from a Notary we trust.
    if parsed_key != notary_key {
        return Err(
            "The key used to sign the attestation is not from a Notary we trust."
                .to_string()
                .into(),
        );
    }

    let provider = CryptoProvider::default();

    // Verify the presentation.
    let PresentationOutput {
        server_name,
        connection_info,
        transcript,
        ..
    } = presentation.verify(&provider).unwrap();

    // The time at which the connection was started.
    let time = chrono::DateTime::UNIX_EPOCH + Duration::from_secs(connection_info.time);
    let server_name = server_name.unwrap();
    let mut partial_transcript = transcript.unwrap();
    // Set the unauthenticated bytes so they are distinguishable.
    partial_transcript.set_unauthed(b'X');

    let sent = String::from_utf8_lossy(partial_transcript.sent_unsafe());
    let recv = String::from_utf8_lossy(partial_transcript.received_unsafe());

    println!("-------------------------------------------------------------------");
    println!(
        "Successfully verified that the bytes below came from a session with {:?} at {}.",
        server_name, time
    );
    println!("Note that the bytes which the Prover chose not to disclose are shown as X.");
    println!();
    println!("Messages sent:");
    println!();
    println!("{sent}");
    println!();
    println!("Messages received:");
    println!();
    println!("{recv}");
    println!("-------------------------------------------------------------------");

    Ok(())
}

/// Returns a Notary pubkey trusted by this Verifier
fn notary_pubkey() -> Result<k256::PublicKey, String> {
    let pem_file = include_str!("../../tlsn/notary.pub");

    k256::PublicKey::from_public_key_pem(pem_file)
        .map_err(|e| format!("Failed to parse Notary pubkey: {e}"))
}
