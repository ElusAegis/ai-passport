use crate::config::VerifyConfig;
use anyhow::{Context, Result};
use dialoguer::console::style;
use dialoguer::{theme::ColorfulTheme, Input};
use std::ops::Not;
use std::time::Duration;
use tlsn_core::presentation::{Presentation, PresentationOutput};
use tlsn_core::signing::VerifyingKey;
use tlsn_core::CryptoProvider;
use tracing::info;

/// A simple verifier which reads a proof generated by `simple_prover.rs` from "proof.json", verifies
/// it and prints the verified data to the console.
pub(crate) fn run_verify(app_conf: &VerifyConfig) -> Result<()> {
    // Deserialize the attestation presentation
    let ser_attestation =
        std::fs::read_to_string(app_conf.proof_path.as_path()).context(format!(
            "Failed to read proof at {}",
            app_conf.proof_path.to_str().unwrap_or("???"),
        ))?;
    let presentation: Presentation = serde_json::from_str(ser_attestation.as_str())
        .context("Failed to deserialize proof generated by a valid proof")?;

    let VerifyingKey { data: key_data, .. } = presentation.verifying_key();

    if app_conf.accept_key.not() {
        confirm_key(key_data)?;
    }

    let provider = CryptoProvider::default();

    // Verify the presentation.
    let PresentationOutput {
        server_name,
        connection_info,
        transcript,
        ..
    } = presentation
        .verify(&provider)
        .context("Failed to verify the presentation")?;

    // The time at which the connection was started.
    let time = chrono::DateTime::UNIX_EPOCH + Duration::from_secs(connection_info.time);
    let server_name = server_name.unwrap();
    let mut partial_transcript = transcript.unwrap();
    // Set the unauthenticated bytes so they are distinguishable.
    partial_transcript.set_unauthed(b'X');

    let sent = String::from_utf8_lossy(partial_transcript.sent_unsafe());
    let recv = String::from_utf8_lossy(partial_transcript.received_unsafe());

    info!(target: "plain", "{}", format!("\n{}", style("-".repeat(70)).dim()));

    info!(target: "plain", "{}", format!(
        "{} {} {} {} {}",
        style("âœ”").green(),
        style("Successfully verified bytes from a session with").bold(),
        style(server_name).blue(),
        style("at").bold(),
        style(time).cyan()
    ));

    info!(target: "plain", "{}", format!(
        "{}",
        style("Note: undisclosed bytes are shown as 'X'")
            .dim()
            .italic()
    ));

    info!(target: "plain", "");

    info!(target: "plain", "{}", style("ðŸ“¤ Messages sent:").bold().underlined().to_string());
    info!(target: "plain", "{}", sent);
    info!(target: "plain", "");

    info!(target: "plain", "{}",
        style("ðŸ“¥ Messages received:")
            .bold()
            .underlined()
            .to_string(),
    );
    info!(target: "plain", "{}", recv);

    info!(target: "plain", "{}", format!("{}", style("-".repeat(70)).dim()));

    Ok(())
}

fn confirm_key(key_data: &Vec<u8>) -> Result<()> {
    // Show verifying key (styled, consistent with rest of CLI)
    let key_hex = hex::encode(key_data);
    info!(target: "plain",
        "\n{} {} {}",
        style("ðŸ”‘").yellow(),
        style("Verifying presentation with key").bold(),
        style(format!("0x{key_hex}")).red(),
    );
    info!(target: "plain",
        "{} {} {}",
        style("âš ").yellow(),
        style("Do you trust this key?").bold(),
        style("Type YES to continue").dim(),
    );

    // Require explicit YES + Enter to proceed
    let confirm: String = Input::with_theme(&ColorfulTheme::default())
        .with_prompt(format!("{}", style("Confirm (type YES)").bold()))
        .allow_empty(false)
        .interact_text()
        .context("reading key trust confirmation")?;

    if confirm.trim() != "YES" {
        anyhow::bail!("Verification aborted: key not accepted");
    }
    Ok(())
}
